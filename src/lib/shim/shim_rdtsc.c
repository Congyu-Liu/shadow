/*
 * The Shadow Simulator
 * See LICENSE for licensing information
 */

#include <errno.h>
#include <signal.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/ucontext.h>

#include "lib/logger/logger.h"
#include "lib/shim/shim.h"
#include "lib/shim/shim_logger.h"
#include "lib/shim/shim_signals.h"
#include "lib/shim/shim_sys.h"
#include "lib/shim/shim_syscall.h"
#include "lib/shim/shim_tls.h"
#include "lib/tsc/tsc.h"

static void _shim_rdtsc_emulate_sigsegv(siginfo_t* info, ucontext_t* ucontext) {
    ShimShmemHostLock* host_lock = shimshmemhost_lock(shim_hostSharedMem());

    shd_kernel_sigset_t pending_signals =
        shimshmem_getThreadPendingSignals(host_lock, shim_threadSharedMem());
    if (shd_sigismember(&pending_signals, SIGSEGV)) {
        warning("SIGSEGV with SIGSEGV already pending");
    } else {
        shd_sigaddset(&pending_signals, SIGSEGV);
        shimshmem_setThreadPendingSignals(host_lock, shim_threadSharedMem(), pending_signals);
        shimshmem_setThreadSiginfo(host_lock, shim_threadSharedMem(), SIGSEGV, info);
    }

    shim_process_signals(host_lock, ucontext);

    shimshmemhost_unlock(shim_hostSharedMem(), &host_lock);
}

static void _shim_rdtsc_handle_sigsegv(int sig, siginfo_t* info, void* voidUcontext) {
    bool oldNativeSyscallFlag = shim_swapAllowNativeSyscalls(true);

    // FIXME: if oldNativeSyscallFlag was false, crash on non-rdtsc.
    // (What to do with rdtsc?)

    // Detect recursion. Recursion is *usually* a sign of a bug in our handling
    // code, but could also occur in a configured sigsegv handler.
    static ShimTlsVar in_handler_storage = {0};
    bool* in_handler = shimtlsvar_ptr(&in_handler_storage, sizeof(*in_handler));
    if (*in_handler) {
        warning("Recursive sigsegv; possible bug in shim segv handling code");
    }
    *in_handler = true;

    trace("Trapped sigsegv");
    static bool tsc_initd = false;
    static Tsc tsc;
    if (!tsc_initd) {
        trace("Initializing tsc");
        uint64_t hz;
        // TODO: We should move this to host shared memory and avoid parsing
        // here.
        if (sscanf(getenv("SHADOW_TSC_HZ"), "%" PRIu64, &hz) != 1) {
            panic("Couldn't parse SHADOW_TSC_HZ %s", getenv("SHADOW_TSC_HZ"));
        }
        tsc = Tsc_create(hz);
        tsc_initd = true;
    }

    // SIGSEGVs generated by executing an rdtsc or rdstscp
    // instruction after disabling them with `prctl` has a code of SI_KERNEL.
    // While this doesn't appear to be specifically documented, it's really the
    // only code documented in `sigaction(2)` that would make sense. e.g.,
    // a SIGSEGV caused by accessing an unmapped region would have code
    // SEGV_MAPERR.
    //
    // Explicitly performing this check helps prevent accessing a potentially
    // inaccessible pointer below to read the program counter.
    if (info->si_code != SI_KERNEL) {
        trace("si_code=%d, not SI_KERNEL. Emulating.", info->si_code);
        _shim_rdtsc_emulate_sigsegv(info, voidUcontext);
        shim_swapAllowNativeSyscalls(oldNativeSyscallFlag);
        return;
    }

    ucontext_t* ctx = (ucontext_t*)(voidUcontext);
    greg_t* regs = ctx->uc_mcontext.gregs;

    unsigned char* insn = (unsigned char*)regs[REG_RIP];
    if (isRdtsc(insn)) {
        trace("Emulating rdtsc");
        uint64_t rax, rdx;
        uint64_t rip = regs[REG_RIP];
        Tsc_emulateRdtsc(&tsc, &rax, &rdx, &rip, shim_sys_get_simtime_nanos());
        regs[REG_RDX] = rdx;
        regs[REG_RAX] = rax;
        regs[REG_RIP] = rip;
    } else if (isRdtscp(insn)) {
        trace("Emulating rdtscp");
        uint64_t rax, rdx, rcx;
        uint64_t rip = regs[REG_RIP];
        Tsc_emulateRdtscp(&tsc, &rax, &rdx, &rcx, &rip, shim_sys_get_simtime_nanos());
        regs[REG_RDX] = rdx;
        regs[REG_RAX] = rax;
        regs[REG_RCX] = rcx;
        regs[REG_RIP] = rip;
    } else {
        trace("sigsegv not due to rdtsc. Emulating.");
        _shim_rdtsc_emulate_sigsegv(info, voidUcontext);
        shim_swapAllowNativeSyscalls(oldNativeSyscallFlag);
        return;
    }
    *in_handler = false;
    shim_swapAllowNativeSyscalls(oldNativeSyscallFlag);
}

void shim_rdtsc_init() {
    // Force a SEGV on any rdtsc or rdtscp instruction.
    if (prctl(PR_SET_TSC, PR_TSC_SIGSEGV) < 0) {
        panic("pctl: %s", strerror(errno));
    }

    // Install our own handler to emulate.
    if (sigaction(SIGSEGV,
                  &(struct sigaction){
                      .sa_sigaction = _shim_rdtsc_handle_sigsegv,
                      // SA_NODEFER: Handle recursive SIGSEGVs, so that it can
                      // "rethrow" the SIGSEGV and in case of a bug in the
                      // handler.
                      // SA_SIGINFO: Required because we're specifying
                      // sa_sigaction.
                      // SA_ONSTACK: Use the alternate signal handling stack, to avoid interfering
                      // with userspace thread stacks.
                      .sa_flags = SA_SIGINFO | SA_NODEFER | SA_ONSTACK,
                  },
                  NULL) < 0) {
        panic("sigaction: %s", strerror(errno));
    }
}
